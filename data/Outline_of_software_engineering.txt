The following outline is provided as an overview of and topical guide to software engineering: Software engineering – application of a systematic, disciplined, quantifiable approach to the development...

The following outline is provided as an overview of and topical guide to software engineering:
Software engineering – application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is the application of engineering to software.
The ACM Computing Classification system is a poly-hierarchical ontology that organizes the topics of the field and can be used in semantic web applications and as a de facto standard classification system for the field.   The major section "Software and its Engineering" provides an outline and ontology for software engineering.


== Software applications ==
Software engineers build software (applications, operating systems, system software) that people use.
Applications influence software engineering by pressuring developers to solve problems in new ways. For example, consumer software emphasizes low cost, medical software emphasizes high quality, and Internet commerce software emphasizes rapid development.

Business software
Accounting software
Analytics
Data mining closely related to database
Decision support systems
Airline reservations
Banking
Automated teller machines
Cheque processing
Credit cards
Commerce
Trade
Auctions (e.g. eBay)
Reverse auctions (procurement)
Bar code scanners
Compilers
Parsers
Compiler optimization
Interpreters
Linkers
Loaders
Communication
E-mail
Instant messengers
VOIP
Calendars — scheduling and coordinating
Contact managers
Computer graphics
Animation
Special effects for video and film
Editing
Post-processing
Cryptography
Databases, support almost every field
Embedded systems Both software engineers and traditional engineers write software control systems for embedded products.
Automotive software
Avionics software
Heating ventilating and air conditioning (HVAC) software
Medical device software
Telephony
Telemetry
Engineering All traditional engineering branches use software extensively. Engineers use spreadsheets, more than they ever used calculators. Engineers use custom software tools to design, analyze, and simulate their own projects, like bridges and power lines. These projects resemble software in many respects, because the work exists as electronic documents and goes through analysis, design, implementation, and testing phases. Software tools for engineers use the tenets of computer science; as well as the tenets of calculus, physics, and chemistry.
Computer Aided Design (CAD)
Electronic Design Automation (EDA)
Numerical Analysis
Simulation
File
FTP
File sharing
File synchronization
Finance
Bond market
Futures market
Stock market
Games
Poker
Multiuser Dungeons
Video games
Information systems, support almost every field
LIS Management of laboratory data
MIS Management of financial and personnel data
Logistics
Supply chain management
Manufacturing
Computer Aided Manufacturing (CAM)
Distributed Control Systems (DCS)
Music
Music sequencers
Sound effects
Music synthesis
Network Management
Network management system
Element Management System
Operations Support System
Business Support Systems
Networks and Internet
Domain Name System
Protocols
Routers
Office suites
Word processors
Spreadsheets
Presentations
Operating systems
Embedded
Graphical
Multitasking
Real-time
Robotics
Signal processing, encoding and interpreting signals
Image processing, encoding and interpreting visual information
Speech processing
Text recognition
Handwriting recognition
Simulation, supports almost every field.
Engineering, A software simulation can be cheaper to build and more flexible to change than a physical engineering model.
Sciences
Sciences
Genomics
Traffic Control
Air traffic control
Ship traffic control
Road traffic control
Training
Drill
Simulation
Testing
Visualization, supports almost every field
Architecture
Engineering
Sciences
Voting
World Wide Web
Browsers
Servers


== Software engineering topics ==


=== Programming paradigm, based on a programming language technology ===
Object-oriented programming
Aspect-oriented programming
Functional decomposition
Structured programming
Rule-based programming


=== Databases ===
Hierarchical
Object
Relational
SQL/XML
SQL
MYSQL
NoSQL


=== Graphical user interfaces ===
GTK+ GIMP Toolkit
wxWidgets
Ultimate++
Qt toolkit
FLTK


=== Programming tools ===
Configuration management and source code management
CVS
Subversion
Git
Mercurial
RCS
GNU Arch
LibreSource Synchronizer
Team Foundation Server
Visual Studio Team Services
Build tools
Make
Rake
Cabal
Ant
CADES
Nant
Maven
Final Builder
Gradle
Team Foundation Server
Visual Studio Team Services
Visual Build Pro
Editors
Integrated development environments (IDEs)
Text editors
Word processors
Parser creation tools
Yacc/Bison
Static code analysis tools


=== Libraries ===
Component-based software engineering


=== Design languages ===
Unified Modeling Language (UML)


=== Patterns, document many common programming and project management techniques ===
Anti-patterns
Patterns


=== Processes and methodologies ===
Agile
Agile software development
Extreme programming
Lean software development
Rapid application development (RAD)
Rational Unified Process
Scrum
Heavyweight
Cleanroom
ISO/IEC 12207 — software life cycle processes
ISO 9000 and ISO 9001
Process Models
CMM and CMMI/SCAMPI
ISO 15504 (SPICE)
Metamodels
ISO/IEC 24744
SPEM


=== Platforms ===
A platform combines computer hardware and an operating system. As platforms grow more powerful and less costly, applications and tools grow more widely available.

BREW
Cray supercomputers
DEC minicomputers
IBM mainframes
Linux PCs
Classic Mac OS and macOS PCs
Microsoft .NET
Palm PDAs
Sun Microsystems Solaris
Windows PCs (Wintel)
Symbian OS


=== Other Practices ===
Communication
Method engineering
Pair programming
Performance Engineering
Programming productivity
Refactoring
Software inspections/Code reviews
Software reuse
Systems integration
Teamwork


=== Other tools ===
Decision tables
Feature
User stories
Use cases


=== Computer science topics ===
Skilled software engineers know a lot of computer science including what is possible and impossible, and what is easy and hard for software.

Algorithms, well-defined methods for solving specific problems.
Searching
Sorting
Parsing
Numerical analysis
Compiler theory
Yacc/Bison
Data structures, well-defined methods for storing and retrieving data.
Lists
Trees
Hash tables
Computability, some problems cannot be solved at all
List of unsolved problems in computer science
Halting problem
Complexity, some problems are solvable in principle, yet unsolvable in practice
NP completeness
Computational complexity theory
Formal methods
Proof of correctness
Program synthesis
Adaptive Systems
Neural Networks
Evolutionary Algorithms


=== Mathematics topics ===
Discrete mathematics is a key foundation of software engineering.

Number representation
Set (computer science)
Bags
Graphs
Sequences
Trees
Graph (data structure)
Logic
Deduction
First-order logic
Higher-order logic
Combinatory logic
Induction
Combinatorics
Other

Domain knowledge
Statistics
Decision theory
Type theory


=== Life cycle phases ===
Development life cycle phase
Requirements gathering / analysis
Software architecture
Computer programming
Testing, detects bugs
Black box testing
White box testing
Quality assurance, ensures compliance with process.
Product Life cycle phase and Project lifecycle
Inception
First development
Major release
Minor release
Bug fix release
Maintenance
Obsolescence
Release development stage, near the end of a release cycle
Alpha
Beta
Gold master
1.0; 2.0
Software development lifecycle
Waterfall model — Structured programming and Stepwise refinement
SSADM
Spiral model — Iterative development
V-model
Agile software development
DSDM
Chaos model — Chaos strategy


=== Deliverables ===
Deliverables must be developed for many SE projects. Software engineers rarely make all of these deliverables themselves. They usually cooperate with the writers, trainers, installers, marketers, technical support people, and others who make many of these deliverables.

Application software — the software
Database — schemas and data.
Documentation, online and/or print, FAQ, Readme, release notes, Help, for each role
User
Administrator
Manager
Buyer
Administration and Maintenance policy, what should be backed-up, checked, configured, ...
Installers
Migration
Upgrade from previous installations
Upgrade from competitor's installations
Training materials, for each role
User
Administrator
Manager
Buyer
Support info for computer support groups.
Marketing and sales materials
White papers, explain the technologies used in the applications


=== Business roles ===
Operations
Users
Administrators
Managers
Buyers
Development
Analysts
Programmers
Testers
Managers
Business
Consulting — customization and installation of applications
Sales
Marketing
Legal — contracts, intellectual property rights
Privacy and Privacy engineering
Support — helping customers use applications
Personnel — hiring and training qualified personnel
Finance — funding new development
Academe
Educators
Researchers


=== Management topics ===
Leadership
Coaching
Communication
Listening
Motivation
Vision, SEs are good at this
Example, everyone follows a good example best
Human resource management
Hiring, getting people into an organization
Training
Evaluation
Project management
Goal setting
Customer interaction (Rethink)
Estimation
Risk management
Change management
Process management
Software development processes
Metrics


=== Business topics ===
Quality programs
Malcolm Baldrige National Quality Award
Six Sigma
Total Quality Management (TQM)


== Software engineering profession ==
Software engineering demographics
Software engineering economics
CCSE
History of software engineering
Software engineering professionalism
Ethics
Licensing
Legal
Intellectual property
Consumer protection


== History of software engineering ==
History of software engineering


=== Pioneers ===
Many people made important contributions to SE technologies, practices, or applications.

John Backus: Fortran, first optimizing compiler, BNF
Victor Basili: Experience factory.
F.L. Bauer: Stack principle, popularized the term Software Engineering
Kent Beck: Refactoring, extreme programming, pair programming, test-driven development.
Tim Berners-Lee: World Wide Web
Barry Boehm: SE economics, COCOMO, Spiral model.
Grady Booch: Object-oriented design, UML.
Fred Brooks: Managed System 360 and OS 360. Wrote The Mythical Man-Month and No Silver Bullet.
Larry Constantine: Structured design, coupling, cohesion
Edsger Dijkstra: Wrote Notes on Structured Programming, A Discipline of Programming and Go To Statement Considered Harmful, algorithms, formal methods, pedagogy.
Michael Fagan: Software inspection.
Tom Gilb: Software metrics, Software inspection, Evolutionary Delivery ("Evo").
Adele Goldstine: Wrote the Operators Manual for the ENIAC, the first electronic digital computer, and trained some of the first human computers
Lois Haibt: FORTRAN, wrote the first parser
Margaret Hamilton: Coined the term "software engineering", developed Universal Systems Language
Mary Jean Harrold: Regression testing, fault localization
Grace Hopper: The first compiler (Mark 1), COBOL, Nanoseconds.
Watts Humphrey: Capability Maturity Model, Personal Software Process, fellow of the Software Engineering Institute.
Jean Ichbiah: Ada
Michael A. Jackson: Jackson Structured Programming, Jackson System Development
Bill Joy: Berkeley Unix, vi, Java.
Alan Kay: Smalltalk
Brian Kernighan: C and Unix.
Donald Knuth: Wrote The Art of Computer Programming, TeX, algorithms, literate programming
Nancy Leveson: System safety
Bertrand Meyer: Design by Contract, Eiffel programming language.
Peter G. Neumann: RISKS Digest, ACM Sigsoft.
David Parnas: Module design, social responsibility, professionalism.
Jef Raskin: Developed the original Macintosh GUI, authored The Humane Interface
Dennis Ritchie: C and Unix.
Winston W. Royce: Waterfall model.
Mary Shaw: Software architecture.
Richard Stallman: Founder of the Free Software Foundation
Linus Torvalds: Linux kernel, free software / open source development.
Will Tracz: Reuse, ACM Software Engineering Notes.
Gerald Weinberg: Wrote The Psychology of Computer Programming.
Elaine Weyuker: Software testing
Jeannette Wing: Formal specifications.
Ed Yourdon: Structured programming, wrote The Decline and Fall of the American Programmer.
See also

List of programmers
List of computer scientists


== Notable publications ==
About Face: The Essentials of User Interface Design by Alan Cooper, about user interface design. ISBN 0-7645-2641-3
The Capability Maturity Model by Watts Humphrey. Written for the Software Engineering Institute, emphasizing management and process. (See Managing the Software Process ISBN 0-201-18095-2)
The Cathedral and the Bazaar by Eric Raymond about open source development.
The Decline and Fall of the American Programmer by Ed Yourdon predicts the end of software development in the U.S. ISBN 0-13-191958-X
Design Patterns by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. ISBN 0-201-63361-2
Extreme Programming Explained by Kent Beck ISBN 0-321-27865-8
"Go To Statement Considered Harmful" by Edsger Dijkstra.
"Internet, Innovation and Open Source:Actors in the Network" — First Monday article by Ilkka Tuomi (2000) source
The Mythical Man-Month by Fred Brooks, about project management. ISBN 0-201-83595-9
Object-oriented Analysis and Design by Grady Booch. ISBN 0-8053-5340-2
Peopleware by Tom DeMarco and Tim Lister.  ISBN 0-932633-43-9
The pragmatic engineer versus the scientific designer by E. W. Dijkstra [1]
Principles of Software Engineering Management by Tom Gilb about evolutionary processes. ISBN 0-201-19246-2
The Psychology of Computer Programming by Gerald Weinberg. Written as an independent consultant, partly about his years at IBM. ISBN 0-932633-42-0
Refactoring: Improving the Design of Existing Code by Martin Fowler, Kent Beck, John Brant, William Opdyke, and Don Roberts. ISBN 0-201-48567-2
The Pragmatic Programmer: from journeyman to master by Andrew Hunt, and David Thomas. ISBN 0-201-61622-X
Software Engineering Body of Knowledge (SWEBOK) ISO/IEC TR 19759


== Related fields ==
Computer science
Information engineering
Information technology
Traditional engineering
Computer engineering
Electrical engineering
Software engineering
Domain engineering
Information technology engineering
Knowledge engineering
User interface engineering
Web engineering
Arts and Sciences
Mathematics
Computer science
Information science
Application software
Information systems
Programming
Systems Engineering


== See also ==
Index of software engineering articles
Search-based software engineering
SWEBOK Software engineering body of knowledge
CCSE Computing curriculum for software engineering
Computer terms etymology, the origins of computer terms
Complexity or scaling
Second system syndrome
optimization
Source code escrow
Feature interaction problem
Certification (software engineering)
Engineering disasters#Failure due to software
Outline of software development
List of software development philosophies


== References ==


== External links ==

ACM Computing Classification System
Guide to the Software Engineering Body of Knowledge (SWEBOK)
Professional organizations
British Computer Society
Association for Computing Machinery
IEEE Computer Society
Professionalism
SE Code of Ethics
Professional licensing in Texas
Education
CCSE Undergraduate curriculum
Standards

IEEE Software Engineering Standards
Internet Engineering Task Force
ISO
Government organizations

European Software Institute
Software Engineering Institute
Agile

Organization to promote Agile software development
Test driven development
Extreme programming
Other organizations

Online community for software engineers
Software Engineering Society
Demographics
U.S. Bureau of Labor Statistics on SE
Surveys

David Redmiles page from the University of California site
Other

Full text in PDF from the NATO conference in Garmisch
Computer Risks Peter G. Neumann's risks column.